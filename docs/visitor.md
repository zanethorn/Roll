# AST Visitor Pattern

The Roll dice library provides a visitor pattern interface for exploring Abstract Syntax Trees (ASTs) generated by the parser. This allows consumers of the library to create custom tools for analyzing, transforming, or displaying parsed dice expressions.

## Overview

The visitor pattern implementation consists of:

1. **`dice_ast_visitor_t`** - Structure defining visitor callback functions
2. **`dice_ast_traverse()`** - Function to traverse AST using a visitor
3. **`dice_create_trace_visitor()`** - Built-in visitor for displaying AST structure

## Visitor Interface

```c
typedef struct dice_ast_visitor {
    // Called when entering any node (pre-order)
    void (*enter_node)(const dice_ast_node_t *node, void *user_data);
    
    // Called when exiting any node (post-order)
    void (*exit_node)(const dice_ast_node_t *node, void *user_data);
    
    // Specific node type handlers (optional - can be NULL)
    void (*visit_literal)(const dice_ast_node_t *node, void *user_data);
    void (*visit_binary_op)(const dice_ast_node_t *node, void *user_data);
    void (*visit_dice_op)(const dice_ast_node_t *node, void *user_data);
    void (*visit_function_call)(const dice_ast_node_t *node, void *user_data);
    void (*visit_annotation)(const dice_ast_node_t *node, void *user_data);
    
    // User data pointer passed to all visitor methods
    void *user_data;
} dice_ast_visitor_t;
```

## Basic Usage

### Simple Node Counter

```c
typedef struct {
    int total_nodes;
    int literals;
    int dice_ops;
} node_counter_t;

void count_enter_node(const dice_ast_node_t *node, void *user_data) {
    node_counter_t *counter = (node_counter_t *)user_data;
    counter->total_nodes++;
}

void count_literal(const dice_ast_node_t *node, void *user_data) {
    node_counter_t *counter = (node_counter_t *)user_data;
    counter->literals++;
}

void count_dice_op(const dice_ast_node_t *node, void *user_data) {
    node_counter_t *counter = (node_counter_t *)user_data;
    counter->dice_ops++;
}

// Usage
dice_context_t *ctx = dice_context_create(64 * 1024, DICE_FEATURE_ALL);
dice_ast_node_t *ast = dice_parse(ctx, "3d6+2d8+5");

node_counter_t counter = {0};
dice_ast_visitor_t visitor = {0};
visitor.enter_node = count_enter_node;
visitor.visit_literal = count_literal;
visitor.visit_dice_op = count_dice_op;
visitor.user_data = &counter;

dice_ast_traverse(ast, &visitor);

printf("Total nodes: %d, Literals: %d, Dice operations: %d\n", 
       counter.total_nodes, counter.literals, counter.dice_ops);
```

### AST Validator

```c
typedef struct {
    bool valid;
    const char *error_message;
} validator_state_t;

void validate_dice_op(const dice_ast_node_t *node, void *user_data) {
    validator_state_t *state = (validator_state_t *)user_data;
    
    if (!state->valid) return; // Already invalid
    
    // Check for reasonable dice counts and sides
    if (node->data.dice_op.count && 
        node->data.dice_op.count->type == DICE_NODE_LITERAL) {
        int64_t count = node->data.dice_op.count->data.literal.value;
        if (count > 1000) {
            state->valid = false;
            state->error_message = "Too many dice in single roll";
            return;
        }
    }
    
    if (node->data.dice_op.sides && 
        node->data.dice_op.sides->type == DICE_NODE_LITERAL) {
        int64_t sides = node->data.dice_op.sides->data.literal.value;
        if (sides > 1000) {
            state->valid = false;
            state->error_message = "Too many sides on die";
            return;
        }
    }
}

// Usage
validator_state_t validator = {true, NULL};
dice_ast_visitor_t visitor = {0};
visitor.visit_dice_op = validate_dice_op;
visitor.user_data = &validator;

dice_ast_traverse(ast, &visitor);

if (!validator.valid) {
    printf("Validation failed: %s\n", validator.error_message);
}
```

## Built-in Trace Visitor

The library provides a default trace visitor for displaying AST structure:

```c
// Create trace visitor
dice_ast_visitor_t trace_visitor = dice_create_trace_visitor(stdout, "  ");

// Traverse and display AST
dice_ast_traverse(ast, &trace_visitor);
```

### Example Output

For the expression `"3d6+2"`:

```
BINARY_OP {
  operator: +
  left:
  right:
  DICE_OP {
    dice_type: BASIC
    count:
    sides:
    LITERAL {
      value: 3
    }
    LITERAL {
      value: 6
    }
  }
  LITERAL {
    value: 2
  }
}
```

## CLI Integration

The roll CLI tool supports AST display with the `--ast` flag:

```bash
$ roll --ast "2*(1d6+3)"
AST structure for '2*(1d6+3)':
BINARY_OP {
  operator: *
  left:
  right:
  LITERAL {
    value: 2
  }
  BINARY_OP {
    operator: +
    left:
    right:
    DICE_OP {
      dice_type: BASIC
      count:
      sides:
      LITERAL {
        value: 1
      }
      LITERAL {
        value: 6
      }
    }
    LITERAL {
      value: 3
    }
  }
}

18
```

## AST Node Types

The visitor pattern handles all AST node types:

- **`DICE_NODE_LITERAL`** - Numeric constants (`42`, `6`)
- **`DICE_NODE_BINARY_OP`** - Math operations (`+`, `-`, `*`, `/`)
- **`DICE_NODE_DICE_OP`** - Dice rolls (`3d6`, `2d10kh1`)
- **`DICE_NODE_FUNCTION_CALL`** - Function calls (future use)
- **`DICE_NODE_ANNOTATION`** - Metadata nodes (future use)

## Advanced Features

### Custom Transformations

```c
// Example: Convert all d6 rolls to d8 rolls
void transform_d6_to_d8(const dice_ast_node_t *node, void *user_data) {
    if (node->type == DICE_NODE_DICE_OP && 
        node->data.dice_op.sides && 
        node->data.dice_op.sides->type == DICE_NODE_LITERAL) {
        
        if (node->data.dice_op.sides->data.literal.value == 6) {
            // Note: This requires careful handling of const correctness
            // In practice, you'd create a new AST node
            printf("Found d6 roll to transform to d8\n");
        }
    }
}
```

### Statistical Analysis

```c
typedef struct {
    double min_possible;
    double max_possible;
    double expected_value;
} roll_stats_t;

void analyze_dice_op(const dice_ast_node_t *node, void *user_data) {
    roll_stats_t *stats = (roll_stats_t *)user_data;
    
    if (node->data.dice_op.count && node->data.dice_op.sides &&
        node->data.dice_op.count->type == DICE_NODE_LITERAL &&
        node->data.dice_op.sides->type == DICE_NODE_LITERAL) {
        
        int64_t count = node->data.dice_op.count->data.literal.value;
        int64_t sides = node->data.dice_op.sides->data.literal.value;
        
        stats->min_possible += count;
        stats->max_possible += count * sides;
        stats->expected_value += count * (sides + 1) / 2.0;
    }
}
```

## Thread Safety

- The `dice_ast_traverse()` function is thread-safe for read-only operations
- The built-in trace visitor uses static storage and is **not thread-safe**
- Custom visitors can be designed to be thread-safe by using appropriate user data structures

## Memory Management

- Visitor traversal does not allocate any memory
- All AST nodes are managed by the dice context's arena allocator
- Visitor callbacks should not attempt to free AST nodes
- User data memory management is the responsibility of the visitor implementer

## Best Practices

1. **Always check for NULL**: All visitor callbacks can be NULL
2. **Handle all node types**: Consider what happens when new node types are added
3. **Keep visitors simple**: Complex logic should be factored into helper functions
4. **Document side effects**: If your visitor modifies global state, document it clearly
5. **Test thoroughly**: Use the test framework to verify visitor behavior

## Examples in Tests

See `tests/test_visitor.c` for comprehensive examples of visitor usage, including:

- Basic traversal verification
- Node counting
- Null safety handling
- Trace visitor testing
- Complex expression analysis